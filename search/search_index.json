{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>benny is a modular software playground for making live music.</p> <p>it seamlessly integrates hardware and software, midi and audio, lets you connect anything to anything and extends flexibly into polyphony.</p> <p>benny is a good place to host your own max/msp patches, but you don't need to know max to get started.</p>"},{"location":"#about","title":"About","text":"<p>I (James) made benny because it didn't exist and I wanted it. It's my personal project, designed around my ideas and priorities. I've been using benny for my live sets since early 2023, but it is an ongoing work in progress.</p> <p>I wanted a low distraction interface that is easy to glance at (while performing) and tries to avoid imposing any hierarchical decisions on the user (no global timeline, no pre-defined mixer structure etc).</p> <p>benny is free to download and use. It is open source and you are free to use the code provided in other projects, as long as those projects also come with the same license terms. </p> <p>If you want to get involved there are lots of ways users of all levels can contribute. And if you find benny useful and you can afford it, the tip jar is here.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>benny relies on several other people's work and ideas.</p> <ul> <li>Cycling74 who build max/msp and generously let it run as a free runtime environment.</li> <li>Chris Airwindows whose open source code is an excellent learning resource and also used in various benny blocks.</li> <li>Isabelgk for porting the airwindows VSTs into native max externals.</li> <li>Surreal Machines whose gen filter models are used in a few places in the provided audio blocks.</li> <li>Ernest Meyer whose advanced max + gen tutorials on the c74 forums were instrumental in working out benny's efficient modulation routing system, and whose EPTR oscillator code is used in various places to provide very clean rectangle waves (which are integrated to provide very clean triangle and saw waves too).</li> <li>Luke Abbott for extensive input, inspiration and testing.</li> <li>Michael Terren as I found this essay and others inspirational.</li> <li>Oskari Tamellin who wrote Jeskola Buzz, the first music software I ever used and a huge inspiration for benny's design.</li> </ul>"},{"location":"blocks/","title":"Blocks","text":"<p>Every song in benny is made out of blocks. Blocks are either midi processors, audio processors, representations of hardware attached to the computer or interfaces to control more general things like tempo or tuning system.</p>"},{"location":"blocks/#adding-a-block","title":"Adding a block","text":"<p>Press enter, double click the background or just start typing the name of what you want, to bring up the new block menu.</p>"},{"location":"blocks/#types-of-blocks","title":"Types of blocks","text":""},{"location":"blocks/#audio","title":"Audio","text":"<p>Here is an audio block. This one is an oscillator. Audio blocks have 2 audio inputs, 2 audio outputs, and as many midi inputs and outputs as they want. This block has one voice, represented by the single cuboid section to the right, which has the two meters showing the voice's outputs.</p> <p></p> <p>This is a VST plugin block, which has it's 1 voice split into 2 thinner slices to show you it is a stereo-in stereo-out voice.</p> <p></p> <p>This is a hardware block. Hardware blocks have meters for both benny's output to them and the signals they send back. benny automatically applies a very transparent aliasing-suppressing softclip and dither to all audio outputs to hardware.</p>"},{"location":"blocks/#audio-meters","title":"Audio meters","text":"<p>In benny audio meters (both on blocks and elsewhere) always show the minimum and maximum values that happened during the last frame of video. This is so that you can meaningfully observe signal levels and dynamics and/or cv values.</p>"},{"location":"blocks/#midi","title":"Midi","text":"<p>This block has no audio processing; it is a midi block representing both the keyboard I have connected and the QWERTY keys (when enabled).</p>"},{"location":"blocks/#midi-meters","title":"Midi meters","text":"<p>On midi blocks the meter is a cuboid stretched between the lowest note, the highest note (on the x axis) and the lowest and highest velocities (on the y-axis). The number of currently held notes is indicated by the z-axis/height of the cuboid.</p> <p></p> <p>Some midi blocks output 1-dimensional values, and the meter for these is just a single bar per voice.</p>"},{"location":"blocks/#polyphony","title":"Polyphony","text":"<p>If you press + or - while a block is selected you'll add or remove voices to it. This oscillator has 3 voices, which you can see as additional cuboid slices on the end. Each voice has its own meters. You can connect midi to the the block (which will handle polyphonic midi allocation) or to individual voices. You can adjust and modulate voices all together or separately. Every voice's audio ins and outs are available separately.</p> <p>If you click the cube, you select the whole block. If you click an individual voice's cuboid you select just that voice. See the sidebar section for more on this.</p>"},{"location":"blocks/#interacting-with-blocks","title":"Interacting with blocks","text":"<p>You can click blocks to select. Shift click to select more. Shift drag to select in a rectangle.</p> <p>Ctrl-C, -V, -X do copy / paste / cut.</p> <p>Drag (or arrow keys) to move, drag from one to another to make a new connection. </p> <p>Drag the background to pan around, scroll on the background (or ctrl-drag) to zoom. Home zooms out to show all blocks.</p> <p>Ctrl-click mutes a block. Alt-click bypasses it.</p>"},{"location":"concepts/","title":"Concepts","text":"<ul> <li>the cubes in benny are called blocks. they all make or process sound or musical data. the first page you land on is the blocks page. hit enter, double click or start typing to find blocks to add.</li> <li>the sidebar is where you can see more detailed audio scopes / midi visualisers, parameters, settings and states of a whatever you have selected.</li> <li>connections in benny can go from anything to anything. an audio output can be connected to an audio input, or to a parameter value, or to the midi note input of a synth. every wire has gain and mute controls and wires that translate from one kind of value to another let you choose how that happens</li> <li>almost every block can be made polyphonic. you can add or remove voices as you choose. notes sent to the block get allocated to voices (you can choose how) or you can send notes or audio or modulation directly to individual voices or sets of voices. you can adjust parameters for all voices together, or offset the parameters of individual voices.</li> <li>you can store the current parameter settings of a whole block and all its voices to a 'state'. states can contain settings for some or all of the blocks in a patch. you can trigger states by clicking their buttons in the top bar, or per-block, or xfade between states, or use musical information to trigger state changes using the core.states block.</li> <li>any block can have 1-3 of its parameters assigned to the position of imaginary creatures in a flocking simulation. the creatures are attracted to the parameter slider position but are influenced by a whole load of physical-ish things: friction, weight, attraction to or repulsion from other creatures, a desire to align or to head in different directions, from which many useful auto-modulations can be constructed. a simple 1d example would be eq peaks that move out of each other's way.</li> <li>some blocks have a full screen editor you can bring up, eg for editing sequences. some blocks have a mini-ui they can show in the sidebar with a version of this large editor</li> <li>the second main page of benny is the 'panels' view. you can choose what goes on here - both which blocks get a panel and which parameters show up on the panel. blocks may have mini-uis showing you what they're doing on this page. think of it as a place to build a custom set of controls and visualisation to perform this song.</li> <li>a song is a patch. a liveset is a folder of songfiles. on startup or when you select a new folder benny reads in everything in the folder and preloads as many audio files as it can. it also tries to recycle the voices of previously loaded songs so that it can load a new song as fast as possible. you can 'merge' one song in next to an existing one.</li> <li>meters in benny always show you the minimum and maximum value that happened in the last frame of video. every voice of every block has some kind of meter. midi meters show you the lowest note, highest note, lowest velocity and highest velocity.</li> <li>you can store multiple hardware configuration files for different setups you use. if a hardware block isn't available when loading a song, benny will either auto-substitute or prompt you to choose a replacement. the goal is for a benny-based live set to tolerate on the road equipment failures with minimum fuss.</li> <li>all send/return loops to hardware have aliasing preventing softclip and dither on the outputs. any audio block can be upsampled and run at a higher internal frequency</li> <li>you can arm any blocks to record apart from (at the moment) hardware ones, which you need to route to something else to record.</li> </ul>"},{"location":"connections/","title":"Connections","text":"<p>In benny you can connect anything to anything.</p> <p></p> <p>Drag the source block onto the destination block.</p> <p>To connect just one voice, drag to or from just the voice rather than the main block.</p> <p>A wire will appear, and the sidebar will show the connection detail edit view.</p> <p></p> <p>Here you can select source voice(s), output, destination voice(s) and input. Hitting enter will collapse these choices to the defaults. You can always come back and change any one of them later.</p> <p>There are scopes for both input and output of the connection (where possible).</p> <p>Wire colours reflect the type of output/input they come from.</p> <ul> <li> <p>white : not assigned yet</p> </li> <li> <p>green : values/parameters</p> </li> <li> <p>yellow : midi/notes</p> </li> <li> <p>orange : audio </p> </li> </ul>"},{"location":"connections/#conversion","title":"Conversion","text":"<p>Some connections are simple - eg a midi out to a midi in, or a single audio out to a single audio in. Some require some degree of conversion, which is handled by benny.</p> <p>All connections get a gain/scale control, the ability to flip (invert) their values and a mute button. You can mute a connection by ctrl-click on the wire. You can adjust a connection's level by ctrl-scroll over the wire.</p> <p>Where relevant, connections have offset controls (eg to transpose a midi stream, or add to its velocity).</p> <p></p> <p>When an audio connection is many-to-many, one-to-many or many-to-one, benny shows you the rotate/spread control. This lets you access one set of possible ways of mixing outputs to inputs. It is easy to make ideas such as a polysynth where the next voice's envelope triggers the current voice's filter using this feature.</p> <p></p> <p>When a connection goes from midi (which is a 2-dimensional value, having both pitch and velocity) to a parameter value or to an audio input (which are both 1-dimensional values), benny shows the 'projection angle' control. </p> <p>As on the midi scopes, the Y axis represents velocity, the X axis represents pitch. So: </p> <ul> <li> <p>With the control pointing straight up the output is related only to velocity. </p> </li> <li> <p>With it pointing down the output is inversely related to velocity.</p> </li> <li> <p>If it points horizontally right the output is related only to pitch. </p> </li> <li> <p>Left, to inverse of pitch.</p> </li> <li> <p>Angles between are some combination of these.</p> </li> </ul> <p></p> <p>When a 1-dimensional value is sent to a midi input, the converse happens. </p> <p>Using the projection control and pitch and velocity offset sliders you can determine what kind of notes are generated by your incoming value stream - it can affect velocity or pitch or both. </p> <p>The midi scopes will help you understand what's going on.</p>"},{"location":"contribute/","title":"Contribute","text":""},{"location":"contribute/#donate","title":"Donate","text":"<ul> <li>If you find benny useful and you can afford it, the tip jar is here.</li> </ul>"},{"location":"contribute/#report-bugs","title":"Report bugs","text":"<ul> <li>Create a new bug report here.</li> <li>A good bug report contains a clear description of the problem and steps or attached files to reliably reproduce it.</li> <li>In many cases, benny prints useful information to the max console. This may not be visible on your computer, but should come up if you press ctrl-shift-m while on the benny launcher window.</li> <li>If you're not sure, start by opening a discussion instead.</li> </ul>"},{"location":"contribute/#fix-bugs","title":"Fix bugs","text":"<ul> <li>Create a new branch of the repository.</li> <li>Fix the bug in your branch.</li> <li>Submit a pull request to have your fix merged back into the main repository.</li> <li>Any questions or doubts, start a discussion.</li> </ul>"},{"location":"contribute/#contribute-blocks","title":"Contribute blocks","text":"<ul> <li>It's very easy to make blocks. If you make something good and want it to be part of the public repository you are welcome to submit it. You can name your blocks with your own prefix, and that prefix will be given its own section of the blocks menu.</li> <li>Create a new branch, commit your block files to it, submit a pull request.</li> </ul>"},{"location":"contribute/#contribute-vst-plugin-setup-files","title":"Contribute VST plugin setup files","text":"<ul> <li>benny comes with a library of VST plugin config files so it will work out the box with these. If you make a config file for a VST plugin that is not yet included, please submit it to the library via the forum or pull request. </li> </ul>"},{"location":"contribute/#help-with-this-manual","title":"Help with this manual","text":"<ul> <li>This manual is a separate github repository. If you hit a problem or question that isn't answered here please do add your solution to the appropriate section of the manual.</li> </ul>"},{"location":"controllers/","title":"Midi Control","text":"<p>benny is designed to make midi control as fluid as possible. It also attempts to make life easy if you need to change the controllers you use but still be able to play your old songfiles.</p>"},{"location":"controllers/#controllers","title":"Controllers","text":"<p>Controllers - that is midi devices with knobs, sliders or other ways of generating 1-dimensional midi CC or pitchbend messages - are handled by two blocks: core.input.control.auto and core.input.control.basic</p>"},{"location":"controllers/#coreinputcontrolbasic","title":"core.input.control.basic","text":"<p>There can be as many of these as you want. Pick the physical controller you want the block to represent from the list in the sidebar parameters view.</p> <p>Connect from the block to whatever it is that you want to control or modulate. You can move physical controls to automatically select them in the new connection view.</p>"},{"location":"controllers/#coreinputcontrolauto","title":"core.input.control.auto","text":"<p>There can only be one of these core.input.control.auto blocks present at a time. The controller linked to this block can be used for both automap and normal connections. </p>"},{"location":"controllers/#automap","title":"Automap","text":"<p>If automap mode is enabled (in the block's parameters) then when a block is selected the controller will map to it. </p> <p>Controllers with encoders, RGB leds and value feedback are ideal for this (eg Midi Fighter Twister). With a suitable controller the colours and on/off status of knobs match the onscreen ui layout. </p> <p>In the hardware configuration editor you can assign midi buttons to turn automap mode on and off.</p> <p>In automap mode if the selected block has more parameters than can be mapped there is an onscreen button to move to the next page of controls. This can also be linked to a midi button in the hardware configuration editor.</p> <p>You can click the controller icon at the top of the sidebar to turn on automap lock so that it will stay mapped even if you select something else (or nothing).</p>"},{"location":"controllers/#basic-mode","title":"Basic mode","text":"<p>If nothing is selected then the core.input.control.auto block acts in basic mode. </p> <p>You can connect from the controller's outputs to any block as with any other connection in benny. If the controller has per-knob leds they will light up to indicate active connections, using the colours set in the block parameters. </p>"},{"location":"controllers/#block-exclusive-controllers","title":"Block-exclusive controllers","text":"<p>It's also possible for blocks (for example the mixer) to have a fixed, exclusive connection to a particular midi controller. (Developers: you can use controllermanager.js to accomplish this)</p>"},{"location":"controllers/#keyboards","title":"Keyboards","text":"<p>The core.input.keyboard block handles keyboards, grid devices, drum pads, the QWERTY keyboard or any other device that mainly generates midi note messages.</p> <p>QWERTY input needs to be enabled in the block parameters AND capslock needs to be on. The bottom octave starts at Z = C, the top octaves start at Q = C, and ',' and 'L' are up and down octave controls.</p>"},{"location":"controllers/#automap_1","title":"Automap","text":"<p>If the core.input.keyboard block's 'automap' parameter is set to ON then when you select a block or voice that has a midi input the keyboard will map to it automatically. If the block has multiple inputs they'll be listed as buttons, so that you can choose. If you click the keyboard graphic it toggles automap lock and the keyboard will remain mapped even when you select something else (or nothing).</p> <p></p>"},{"location":"controllers/#connections","title":"Connections","text":"<p>You can also connect from the core.input.keyboard block to any other block's midi input, as with any other midi connection in benny.</p> <p>The block also has outputs for modulation, pitchbend (+, -, both) and sustain. If you have a keyboard like the CME XKEY range which outputs continuous polyphonic pressure messages in the form of more note-ons, then the pressure output of this block outputs them separately. There is also a time quantiser for these pressure messages that is synced to the global clock.</p>"},{"location":"controllers/#substitution","title":"Substitution","text":"<p>In the hardware editor for each controller you define you can also select fallback substitutes. These also have to be fully defined in the hardware editor. </p> <p>For example, in my profile I have entries for LPD-8 and LPD-8 MK II. Each is defined as a possible substitute for the other, so in old songs that expect the LPD-8 (which broke) benny finds the MK II attached and uses that instead (and even though they're configured to use different CCs benny will translate them for you).</p> <p>This means that if a piece of equipment fails (for example on tour), then as long as you can find a vaguely similar replacement, you can define that in the hardware editor, set it as the substitute for the failed item, and just load all your songs without having to think about it again.</p>"},{"location":"developing/","title":"Developing blocks","text":"<p>If you already know how to use max/msp then it is easy to make blocks for benny. </p> <p>Every block needs, at minimum:</p> <ul> <li> <p>a .json file describing its inputs, outputs, parameters</p> </li> <li> <p>a .maxpat file (which does the processing - note or audio - for one voice of your block)</p> </li> </ul> <p>Have a look in the <code>docs/block development/example patchers</code> folder. The examples tell you everything you need to do and cover all of the helpful things benny provides, such as precalculated pitch lookup tables and shared memory for things like sequence storage. You can make a patch to manipulate absolutely any part of the song or set. </p> <p>Some of the included blocks draw their own custom fullscreen / mini ui views, and you also have the option to add this functionality to your own blocks. This requires a block_ui_patcher, a new patch which loads separately from the voices. There is a max-only example of this in the note blocks folder, but for more involved interfaces it makes more sense to use javascript. See the included code for examples.</p> <p>If you need help, please do ask on the discussion forum.</p>"},{"location":"faq/","title":"Faq","text":"<ul> <li> <p>max has a console window where benny writes status and error messages. if it's not visible at startup you can make it appear by pressing ctrl-shift-m when the benny launcher window is selected.</p> </li> <li> <p>on OSX it'll pop up loads of quarantine popups. say yes to each and every one. </p> </li> <li> <p>To set a particular song file as your default startup file, save it as 'autoload.json' in the templates folder in the benny folder</p> </li> <li> <p>To assign a mini controller control (e.g. knob) to a parameter, </p> </li> <li> <p>To load a sample to be used in your set, go to the Waves panel, click a box and load it in.</p> </li> <li> <p>To record a performance, select the blocks you want to record, click the record arm shortcut CTRL + R, choose the saved file destination from the top bar, and then click record as you perform your recording. Click record again to finish, the file will be in the destination.</p> </li> <li>benny records both outputs of every voice to a separate WAV file. at the moment hardware blocks can't be recorded directly, so put a VCA set to unity gain after them and record that.</li> <li> <p>if you use the mix channel / stereo channel and mix bus blocks then you have convenient things to record stems / stereo master from</p> </li> <li> <p>To shift from one note pattern (e.g. a melody in the Note Step block) to another (a different melody):</p> </li> </ul> <p>The note step block has a patterns slider that lets you switch between predefined patterns. You could sequence that with a seq.values</p> <p>That block has an output at the end of pattern, designed for if you want to move to the next pattern with it.</p> <ul> <li> <p>Some blocks (seq.analog) store their pattern as parameters. You could sequence these by storing states for different patterns.</p> </li> <li> <p>alternatively, you can modulate the 'start' or 'offset' controls on many sequencers, so you can just write one pattern after the other</p> </li> </ul>"},{"location":"installation/","title":"Installation","text":"<ul> <li> <p>Download the latest benny and extract the whole folder. </p> </li> <li> <p>Install Max. You don't need to buy Max in order to use benny, but if you want to build your own blocks you will need to buy or subscribe. (Please do not bother cycling74 support with problems with benny! We have a forum for that.)</p> </li> <li> <p>A few blocks require Airwindows console 7 VSTs. They're included in the download, look in the VST dependencies subfolder and install the ones you need for your system. </p> <p>Windows users should install VSTs to C:\\Program Files\\VSTPlugins otherwise max/msp can't see them.</p> </li> <li> <p>Open 'benny.maxproj'. The benny launcher window will appear.</p> </li> <li> <p>Open the audio settings and choose which audio driver/interface to use. Generally ASIO drivers are best.</p> </li> </ul> <p>The dropdown contains a list of example hardware configurations. Choose the 'no hardware.json' one then press the start button to try benny out using just the default stereo io on your computer.</p> <p>To set benny up for seamless integration with your midi controllers, modular synth, keyboards, drum machines, synths, microphones, pedals, and outboard effects you'll need to make your own hardware configuration file.</p>"},{"location":"installation/#hardware-configuration","title":"Hardware configuration","text":"<p>To use your hardware fluidly within benny you need to build a configuration file. It will tell benny about each piece of hardware that is connected to your computer, and they will appear as blocks. </p> <p>If you change your hardware setup benny can help you migrate songs from the old to the new, letting you choose substitutes for missing or replaced items. </p> <p>In my usage I have a configuration file for each iteration of my live touring setup, a different one for a setup I have at home and a setup for the studio with my synths and outboard compressors available as individual blocks.</p> <p>The hardware configuration file also includes information about the midi controllers you have connected - how many controls, how they're arranged, the midi channels and protocols etc that they use, and which other controllers work as a substitute.</p> <p>There are example files included that might help - so far i've made configs for:</p> <ul> <li> <p>Midi Fighter Twister (recommended, the led feedback works well with the automapping features in benny)</p> </li> <li> <p>Novation launch control xl</p> </li> <li> <p>Akai lpd8 mk2 (not recommended, incomplete midi implementation)</p> </li> </ul> <p>(A library of presets for controller setup are on my to do list.)</p>"},{"location":"installation/#vst-amxd-configuration","title":"VST / AMXD configuration","text":"<p>To use a VST plugin in benny you need to set it up in the VST / AMXD manager which you open from the benny launcher window. First run the VST plugin scanner and wait until the progress bar has finished.</p> <p>benny comes with a library of config files for VST plugins that we have already encountered. When you run the scan these will be set up automatically, but you are free to make your own edits.</p> <p>If your plugin is not automatically added to benny you can set it up in the VST manager. You need to tell it which parameters you want to see, and what order they should appear in. At the moment it lets you assign them to 4 groups (1 group = 1 row of sliders in the benny interface).</p> <p>If you've done a complete and useable configuration for a plugin please do post the .json file (found in benny/audio_blocks) on the discussions pages and we'll add it to the library.</p> <p>Max for live devices (AMXD's) are set up similarly, but at present there is no scanner or library for these. Just press the 'add AMXD' button to browse for an AMXD file to import. Devices that use the live API (eg ones that manipulate live sets, or work with modulation inside live) aren't likely to work in benny, but most simple synths and effects do.</p>"},{"location":"installation/#preferences","title":"Preferences","text":"<p>All the visual/ui preferences - colour palette, wire curve detail and various behaviours with self explanatory names, are in config.json. If you want to change a setting:</p> <ul> <li> <p>copy the whole line for that setting and paste it into userconfig.json</p> </li> <li> <p>anything in userconfig.json overrides the default value in config.json. it is created in the root of the benny folder after you first run benny.</p> </li> <li> <p>config.json will be overwritten with defaults next time you update benny but userconfig.json will not.</p> </li> </ul> <p>If the glow effect is too much for your taste, add the following line to userconfig.json:</p> <pre><code>\"glow\" : 0,\n</code></pre> <p>If you'd like different blocks present at startup you can save over autoload.json in the templates folder.</p>"},{"location":"installation/#updates","title":"Updates","text":"<p>At the moment, benny follows a continuous update schedule. You can get the latest version by downloading it and unzipping it over the top of your current benny install. Or it's slightly more convenient to use a 'git' client (github desktop is free and fine for this). First 'clone' the benny repository and then just 'fetch' every time you want an update.</p>"},{"location":"installation/#recommended-computer-specs","title":"Recommended computer specs","text":"<p>benny is fairly resource intensive. A lot of graphic work is handled by the GPU but if you have an old laptop with only integrated graphics it may struggle. See below for some settings that can lighten the load on the GPU.</p> <p>The audio side of benny takes full advantage of multi core CPUs (afaik this is an advantage over hosting patches in Max for Live, which last time I checked, doesn't).</p> <p>We've tested benny on the systems below, and hope it will be useable on any current mid range (integrated graphics only) laptop.</p> <ul> <li> <p>M1 MacBook Air</p> </li> <li> <p>2023 mid range (i7/intel Xe) Framework laptop</p> </li> <li> <p>2019 PC with integrated graphics (AMD 4700G) </p> </li> <li> <p>2024 high end (7950X3D) with a 3050 GPU. </p> </li> </ul>"},{"location":"installation/#resource-usage-sidebar","title":"Resource usage sidebar","text":"<p>benny shows a CPU meter to the left of the play button. You can press F12 to show the resource usage sidebar, which shows CPU usage history (yellow, lower better) and framerate history (white dots, higher better).</p>"},{"location":"installation/#settings-that-affect-gpu-usage","title":"Settings that affect GPU usage:","text":"<ul> <li> <p>Wire segment count. Low end GPUs struggle with the number of polygons needed to make smooth wires. Add the following keys to userconfig.json:</p> <pre><code>\"MAX_BEZIER_SEGMENTS\" : 4,\n\"MIN_BEZIER_SEGMENTS\" : 4,\n</code></pre> <p>(the numbers need to be divisible by 4 and MIN must be &lt; MAX - when loading patches it initially draws the min number then upgrades the wires when it is idle to speed up loading. Defaults are 16 / 8)</p> </li> <li> <p>You can also make it only show wires to/from the current block, either by pressing F10 to toggle, or setting this key to set it as the default:</p> <pre><code>\"WIRES_SHOW_ALL\" : 1,\n</code></pre> </li> </ul>"},{"location":"installation/#settings-that-affect-cpu-usage","title":"Settings that affect CPU usage:","text":"<ul> <li> <p>The maximum number of audio blocks &amp; the number of hardware IO have a big effect on the baseline CPU usage. On mid range hardware the default (64) seems fine, and supports fairly complex song patches. On high end hardware much higher values are possible. On very low end computers you could reduce this to lower the baseline CPU load. Add the following key to userconfig.json</p> <pre><code>\"MAX_AUDIO_VOICES\" : 64,\n</code></pre> </li> <li> <p>The 'vector size' of audio processing also has a big effect. This is the size (in samples) of the chunks of audio worked on by each stage of processing in benny. Decreasing it rapidly increases CPU usage. Find this in the audio settings dialog (there's a button to open it on the benny launcher window). </p> <p>Because of a limitation of benny's architecture every audio connection adds latency proportional to this value, and while it's possible to offset clocks (and other transport-linked blocks eg wave scan blocks also have time offsets) it obviously pays to keep this as low as your computer can manage. On mid range hardware 256 samples is a good target, 64 is a sensible minimum for high end systems.</p> </li> <li> <p>Upsampling is a common simple way to mitigate aliasing in harmonics generated by digital processing. Most of benny's non-linear audio blocks default to upsampling x2 as it makes a noticeable difference to the clarity of the sound. However upsampling obviously increases the CPU usage. You can adjust it (from 1x-128x) in the sidebar settings section for the block, or the following key can be used to disable upsampling for all blocks on a particular computer (for example if your main computer is lost or broken and you borrow a less powerful one to run your set):</p> <pre><code>\"UPSAMPLING\" : 0,\n</code></pre> </li> </ul>"},{"location":"installation/#installation-troubleshooting-faq","title":"Installation Troubleshooting FAQ","text":"<ul> <li> <p>The benny window that comes up when I press start is grey</p> <p>Open max, go in options / preferences / jitter preferences and make sure 'graphics engine' is set to glcore. (This issue only happens if you've had this max installation on your pc for a long while)</p> </li> <li> <p>(macOS) I get the following messages in the max console and benny won't open</p> <pre><code>openactions.txt : can't load, error -1\nbenny_engine.maxpat : can't open\nbenny_engine.maxpat : can't open, error 0\n</code></pre> <p>The person who encountered this found that openactions.txt was set to open with text edit, changing it to open with max solved the problem.</p> </li> <li> <p>(macOS) I get a warning box: External cannot be loaded due to macOS quarantine</p> <p></p> <p>Just click OK as many times as it takes for these to go away, there's nothing to worry about here. Note this only happens if you download and unzip, if you use git (or github desktop or etc) to get benny and keep it up to date the files aren't flagged for quarantine.</p> </li> </ul>"},{"location":"keyboard_shortcuts/","title":"Keyboard shortcuts","text":""},{"location":"keyboard_shortcuts/#global-keys","title":"GLOBAL KEYS","text":"<p>ESC - back out of menus, unselect, recenter blocks view, cancel dragging</p> <p>` - all off (ends all midi notes etc)</p> <p>space - play button</p> <p>ctrl-space - load next song</p> <p>ctrl-s - save</p> <p>CAPS LOCK - when on, the qwerty keyboard is 2.5 octaves of notes, starting at Z up to M for the first octave, then from Q to ]. To go up and down an octave use L and ,.</p> <p>F1 - panels view</p> <p>F2 - blocks view</p> <p>F3 - waves view</p> <p>F4 - open the selected block's custom edit page on the main part of the screen. Press again to hide the sidebar and enlarge the edit page.</p> <p>F6 - sidebar block settings page</p> <p>alt-F6 - open the selected block's voice max patcher for editing.</p> <p>F7 - sidebar connections list page</p> <p>F8 - files page (save/load/merge/choose song folder)</p> <p>F10 - toggle between showing all wires or just those of the selected block (improves performance/reduces GPU load on slow computers)</p> <p>F11 - toggle fullscreen</p> <p>F12 - show resource usage page</p> <p>ctrl-alt-F12 - hard restart benny</p>"},{"location":"keyboard_shortcuts/#blocks-page","title":"BLOCKS PAGE","text":"<p>shift-drag - for a selection rectangle</p> <p>shift-click - to multi-select blocks or wires </p> <p>ctrl-click - to mute blocks or wires</p> <p>ctrl-shift-click - (when unmuting only) holding shift too also 'unmutes the tree' - any muted blocks connected to this one and any muted blocks connected to those, etc.</p> <p>alt-click - to bypass blocks</p> <p>drag - to connect blocks</p> <p>home - center view</p> <p>- or + - change the polyphony of the selected block</p> <p>ctrl-m - toggle mute for the selected blocks</p> <p>ctrl-r - toggle record arm for the selected blocks</p> <p>ctrl-a - select all</p> <p>ctrl-c - copy</p> <p>ctrl-x - cut</p> <p>ctrl-v - paste. </p> <pre><code>- You can copy and paste single or multiple blocks in the blocks view.\n\n- To copy parameter values from block to block: copy a single block, select a target block of the same kind and then paste.\n</code></pre> <p>ctrl-alt-V - paste blocks including their connections. For example, if you copy an oscillator that is connected to a mixer and a midi source, then the pasted duplicate will have the same connections.</p> <p>ctrl-z - undo (currently only undoes delete block, more to come)</p> <p>del / backspace - delete everything selected</p> <p>shift-del - 'delete tree' - deletes the selected blocks, then any blocks that were only connected to/from a deleted block, recursively.</p> <p>shift-T - 'select tree' - selects what delete tree would delete. useful for saving a part of a patch out as a template. by default select tree, delete tree and mute tree all ignore connections to core.input.control.* blocks when counting connections but the config key <code>TREE_SELECT_IGNORES_CONTROL_BLOCKS</code> can change this.</p> <p>alt-left arrow - back to previous sidebar view</p> <p>alt-right arrow - forward to next sidebar view</p> <p>alt-up / alt-down - if you have a wire selected these will take you to the block at the start or end of the wire.</p> <p>insert - if you have a wire selected, insert a block into the connection</p> <p>enter - if you have a wire selected, collapse source / destination input and output menus.</p> <p>enter - open the new block menu</p> <p>tab - toggle between blocks / panels views</p> <p>up / down / left / right - move selected blocks, +shift for fine movement.</p> <p>PGUP / PGDN - zoom in or out</p> <p>ctrl-T - in fullscreen mode benny shows a clock in the top right corner. This key switches to showing a set timer (that starts the first time you press play). ctrl-alt-T resets this timer.</p> <p>? - show help</p> <p>/ - to start searching amongst blocks in the current song</p> <p>any other keys - start typing the name of your chosen block to bring up the new block menu.</p>"},{"location":"keyboard_shortcuts/#panels-page","title":"PANELS PAGE","text":"<p>ctrl-m , tab ,-, + work as on the blocks page.</p>"},{"location":"keyboard_shortcuts/#sidebar","title":"SIDEBAR","text":"<p>scroll / drag - to adjust sliders, zoom scopes etc. +shift for fine, +alt+shift for extra fine.</p> <p>ctrl-hover your mouse over sliders to select an individual voice. scroll+alt+shift to tilt individual voice values around that voice.</p> <p>alt click - to return a slider to its default value (or to the value saved in your songfile).</p>"},{"location":"launcher/","title":"Launcher","text":"<p>When you first open benny a couple of windows should appear:</p>"},{"location":"launcher/#the-benny-launcher-window","title":"The benny launcher window","text":"<p>The dropdown lets you pick the hardware setup you're using, and the start button starts benny. The buttons access audio/VST/hardware setup pages. If you scroll down there are some features for people developing their own blocks or improving benny.</p> <p>You can drag and drop song .json files onto the benny logo to open them directly.</p>"},{"location":"launcher/#the-maxmsp-console-window","title":"The max/msp console window","text":"<p>This is the max/msp console window. benny prints information about what's going on here. if something goes wrong, there may well be useful messages here explaining what and why.</p> <p>If the console isn't visible when you start benny, select the benny launcher and press ctrl-shift-M to bring it up.</p> <p>Additionally the 'project' window sometimes (randomly) opens. You can just close this.</p>"},{"location":"launcher/#the-benny-window","title":"The benny window","text":"<p>When you press start the main benny window opens. F11 makes it fullscreen.</p> <p></p>"},{"location":"live_sets/","title":"Playing live sets with benny","text":"<p>benny was designed not just for composing individual songs, but also for performing live sets.</p> <p>Unlike other live music software benny does not load up all of the songs in a set at once. </p> <p>I felt that in order to play a song properly it would help both the performer and computer not to be burdened by the knowledge of the other songs.</p> <p>When you select a songs folder benny treats the contents of this as your whole live set. When you start benny it preloads all the songfiles, then looks to see if it can preload any samples too. When you choose the next song it recycles as many blocks as it can, so that load times are as quick as possible. </p> <p>If you want to play one song and then the next (stopping in between like a band), then benny will easily load the next song before people stop clapping.</p> <p>If you want to segue seamlessly between songs there are a few approaches:</p> <ul> <li> <p>Merge lets you load the next song in with the current one. All of the new song's blocks appear on the blocks page to the right of the blocks for the song that is currently playing. </p> <p>benny only permits one copy of certain blocks - for example hardware blocks and core.control.input.auto. These blocks are therefore shared between the current and next song, but benny will automatically move them over to their position in the new song.</p> <p>benny also cleans up as you merge: any muted blocks in the old song (and all connected blocks that aren't in use elsewhere) will be deleted as the new song merges in. To disable this behaviour add the following line to userconfig.json:</p> <pre><code>\"PURGE_MUTED_TREES\" : 0,\n</code></pre> <p>After merge you will see two new buttons in the top bar: select previous and select new, which can be used to delete bits of old song.</p> </li> <li> <p>Output blocks </p> <p>In the hardware setup, every audio output on your computer has the option to run another layer of audio processing, called 'output blocks'. By default benny applies a transparent anti-aliasing clipper and dither here. Because these are part of the hardware setup rather than part of the song they are always present, even when benny is loading a new song.</p> <p>There are two (prototype) output blocks included:</p> <ul> <li> <p>The stretch_looper lets you grab a loop of the playing track and keep it looping while the next one loads. It uses z-plane timestretch to make it match the tempo of the next song. This is still a work in progress.</p> </li> <li> <p>The big reverb does what you expect it to.</p> </li> </ul> </li> <li> <p>Hardware loopers, delays or reverbs - anything that can be used to fill 2-10 seconds works here! In my current live setup I've built an external version of the stretch looper that runs in a Bela Pepper Eurorack module and additionally provides an emergency loop in the unlikely event of my computer crashing.</p> </li> </ul> <p>Live set pro-tip: To prevent crashes, tape your usb cables into the ports, at both ends, every time.</p>"},{"location":"mixer/","title":"Mixer","text":"<p>You don't need to structure your patches around a mixer - it's fine to route everything into the main audio outputs if you want - but benny does contain some mixer blocks.</p> <p>The benny mix blocks use airwindows console 7 for non-linear summing. For this to work, you have to go from the mix.channel / mix.stereo.channel blocks into a mix.bus block, and there can't be anything else inbetween the two and this connection has to be at unity gain. benny takes care of this last constraint. You can add more voices to either kind of channel block to add more channels. The three modes (channel, cascade, crunch) give the channels progressively more aggressive saturation characteristics.</p> <p>You can assign a midi controller directly to the mixer in the mix.bus block.</p> <p></p>"},{"location":"panels/","title":"Panels","text":"<p>The panels page of benny is a place to build a set of controls and visualisations to help play the song.</p> <p></p> <p>Every block can have a panel. The panel can show whichever of the block's parameters you choose. (Look for 'panel assign' in the block settings section of the sidebar).</p> <p>Panels also show the states stored for a block.</p> <p>If a block has a mini-ui view the panel will show this too.</p> <p>If you ctrl-click the panels button in the top bar benny enters the panels edit mode, where you can move panels up and down in order and remove unwanted ones.</p>"},{"location":"recording/","title":"Recording","text":""},{"location":"recording/#arming","title":"Arming","text":"<p>To arm a block or blocks for recording, select it/them (shift+click to multiselect) and press ctrl-R.</p> <p></p> <p>The 'set record folder' button will appear in the top bar. Click it and pick a folder.</p> <p>Next to it is the 'record' button. Once you're ready, press record and benny will start to write one stereo wav file for each voice of every armed block. When you turn off recording, the file recording stops. The files are named with the armed block's name, number, and the time. (You can rename blocks by ctrl-clicking)</p> <p>Note: unlike many traditional audio softwares, recording is not tied to the global transport so starting recording does not start playback, and stopping playback does not stop recording.</p> <p>At the moment (due to a technical limitation I haven't yet had time to build a workaround for) hardware blocks cannot be directly recorded. Instead you can connect a dummy block (eg a vca?) after the hardware one and record that.</p>"},{"location":"sidebar/","title":"Sidebar","text":"<p>The sidebar shows the details of whatever you're looking at.</p>"},{"location":"sidebar/#blocks","title":"Blocks","text":"<p>With a single block selected the sidebar shows you all of its settings. Click the section headers to move through them. To rename a block, ctrl-click the topmost header where the block's name is.</p> <p></p> <p>If a block has multiple voices there'll a be a section like this where you can choose to select and adjust either the whole block or an individual voice.</p>"},{"location":"sidebar/#scopes","title":"Scopes","text":"<p>Audio blocks have a scope for each output. The scrollwheel (or dragging up and down) lets you zoom these scopes. Red shows values that go outside the normal ranges (though there is no clipping on connections between blocks).</p> <p></p> <p>Midi scopes show the notes currently playing.</p>"},{"location":"sidebar/#parameters","title":"Parameters","text":"<p>This section shows the parameters for the block. Drag or use your scroll wheel to adjust parameters. </p> <p>Shift for fine adjust.</p> <p>Alt+shift for extra fine. </p> <p>Alt-click returns a value to its default (or if you loaded the songfile from disk, to the value it was in the last save).</p> <p>On these sliders, the darker bar represents the set value of the voice's parameter and the brighter line that usually sits at the end of that bar represents the current actual value. If a parameter is modulated you will see the line moving but not the bar.</p> <p></p> <p>If a block has multiple voices then while you hold ctrl and mouse over a slider it will highlight it and let you adjust that one individually. </p> <p></p> <p>Ctrl+Alt lets you tilt all the values of the individual voices around the one you are hovering over.</p>"},{"location":"sidebar/#mini-ui","title":"Mini-ui","text":"<p>Here's an example of a block with a mini-ui showing what it is doing. Some of these allow mouse interaction. Often they'll have an 'edit' button at the bottom which brings up a full-featured version of the editor on the rest of the screen.</p>"},{"location":"sidebar/#block-settings","title":"Block settings","text":"<p>Reload - does a full hard reload of the block's code.</p> <p>Swap - lets you swap a block out for a different one.</p> <p>Copy paste del do what you would expect.</p> <p>Open patch - opens the max patcher for the first voice of the block.</p>"},{"location":"sidebar/#polyphonic-note-allocation-modes","title":"Polyphonic note allocation modes","text":"<p>Here you set the number of voices and select the mode for picking what voice a new note goes to. There are separate mode settings for how it allocates a note to a currently inactive voice and for when the new note has to steal a currently active voice:</p> <ul> <li> <p>Blind cycle - each note that comes in is allocated to the next voice in turn, without concern for whether that voice is playing or whether the same note is already playing on another voice.</p> </li> <li> <p>Blind random - likewise but the next voice is picked at random</p> </li> <li> <p>Cycle free - the next free voice is picked, working around in order.</p> </li> <li> <p>Cycle random - a voice is picked at random from the currently unused ones.</p> </li> <li> <p>Notememory - it keeps track of which voice last played a particular note and returns to that one. This is how (for example) the Prophet 600 allocated notes to voices.</p> </li> </ul> <p>In the two 'blind' modes successive triggers of the same note (without a noteoff inbetween) get new voices. In the other modes they are allocated to the same voice. The non-blind modes work well with keyboards that send poly pressure messages as a stream of noteon velocities.</p> <p>There are three other controls:</p> <p>Return stolen - if a held note is stopped due to the voice being stolen by a new one and that new note ends, this enables the held note restarting.</p> <p>Stack - plays mutliples of notes, or adds suboctave notes.</p> <p>Latching - only implemented on a few blocks so far, this gives the option for parameters to update only when note on and/or note off events occur (as opposed to continuously, as is the default).</p>"},{"location":"sidebar/#panel-assign","title":"Panel assign","text":"<p>Press the panel assign button to put the sidebar into a mode where you can select parameters to be shown on the panels page.</p>"},{"location":"sidebar/#flock","title":"Flock","text":"<p>benny lets you attach up to 3 parameters to the position of imaginary creatures in a flocking simulation. Once you've assigned parameters to axes using the flock assign button you can adjust the properties of the simulation:</p> <ul> <li> <p>weight</p> </li> <li> <p>tension of the spring connecting the creature to the parameter value </p> </li> <li> <p>friction</p> </li> <li> <p>attraction or repulsion from one another</p> </li> <li> <p>random movement</p> </li> <li> <p>desire to align their motion with the others</p> </li> </ul> <p>This feature can be useful for creating interesting chaotic autovariation, fun parameter-smoothing/overshoot, and for making voices try not to occupy exactly the same parameter space as each other.</p> <p>Ctrl+click on the blocks button in the top bar brings up a visualisation of all flocked blocks.</p>"},{"location":"sidebar/#parameter-errors","title":"Parameter errors","text":"<p>You can introduce per-voice static errors, a gradual (per-voice) drift of parameters, and there is also a 'panel lockup' feature which simulates something my slightly broken Prophet 600 does where randomly, for a few moments, a parameter will stop updating for just one voice.</p>"},{"location":"sidebar/#states","title":"States","text":"<p>When you open this section of the sidebar it lets you store the current parameter values to a State. States that already have values stored in them (either for this block or for others in the song) are highlighted with a border. Alt-click lets you remove this block from a state.</p> <p></p> <p>When this section is not open for editting it just shows buttons that let you fire the states for this block only.</p>"},{"location":"sidebar/#connections","title":"Connections","text":"<p>Here you can see a list of all the connections to and from this block. You can edit them here or click them to bring up the detailed connection edit view.</p>"},{"location":"sidebar/#help","title":"Help","text":"<p>This shows the help text for the block (also visible when you hover over the block in the new block menu).</p>"},{"location":"states/","title":"States","text":"<p>States hold parameter settings for as many or as few blocks as you want.</p>"},{"location":"states/#storing-states","title":"Storing states","text":"<p>With one block selected, in the sidebar click the states section. Click the state you would like to store the current parameters to. You can ctrl-click to remove this block from a state in this section.</p> <p>With multiple blocks selected the sidebar shows an 'add to state' section to add the current parameter settings of all selected blocks to a state.</p>"},{"location":"states/#the-init-state","title":"The init state","text":"<p>Once you save a songfile the initial state of all blocks is stored to the init state, represented by a black square button.</p>"},{"location":"states/#naming-states","title":"Naming states","text":"<p>If you ctrl-click one of the global state buttons (bottom left of the benny window) you can edit the state name.</p> <p></p>"},{"location":"states/#recalling-states","title":"Recalling states","text":"<p>You can recall a state for a single block by clicking the coloured square in the (unexpanded) states section of the sidebar.</p> <p>The panels page also shows (by default, can be disabled in userconfig) a button for every stored state on the panel of the relevant block.</p> <p>To recall a given state for ALL blocks use the global state buttons that are at the bottom left corner of the benny window.</p> <p>The global states init button returns all blocks to the parameter values stored in the songfile. Alt+click on this button also reloads all blocks' 'data' - everything that isn't a parameter that a block stores, for example patterns in sequencers.</p>"},{"location":"states/#state-crossfading","title":"State crossfading","text":"<p>You can crossfade from current parameter values to the ones stored in a state to make a smooth transition.</p> <p></p> <p>Click and hold on one of the global state buttons in the bottom left corner of the window. After a brief pause a horizontal slider appears. Drag to the right to interpolate from the current settings into the stored state.</p>"},{"location":"states/#corestates-block","title":"core.states block","text":"<p>The core.states block lets you trigger state transitions and fades from musical events inside benny.</p>"},{"location":"waves/","title":"Waves","text":"<p>benny keeps all the audio files you use in a centralised repository that all blocks can access. In the waves page you can load in audio files and tag them with timing information.</p> <p>This page of benny is one of the less finished areas. The UI is a bit awkward still and many planned features are not yet implemented.</p> <p></p>"},{"location":"waves/#load-a-wave","title":"Load a wave","text":"<p>Click an empty slot and a file chooser dialog will pop up to let you choose a wave. It will load up and a pictoral representation of it will appear.</p> <p>You can use the scroll wheel to zoom in on the wave.</p>"},{"location":"waves/#slices","title":"Slices","text":"<p>In the future benny will support automatic marker placement and flexible grids with attached metadata.</p> <p>At the moment you can only put a fixed grid of slices on your waves. This is essential for blocks like wave.scan and voice.multisample which work with the slices. </p> <p>Use the sliders to position the start and end of the grid and choose how many slices there are. Alt+shift + scroll for fine adjust.</p> <p></p>"}]}